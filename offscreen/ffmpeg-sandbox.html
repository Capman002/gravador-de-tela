<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <title>FFmpeg Sandbox</title>
  </head>
  <body>
    <!-- 
    Página sandbox para executar FFmpeg.wasm
    Usa arquivos locais para evitar problemas de CSP
  -->
    <script src="../ffmpeg-core/ffmpeg.min.js"></script>
    <script>
      // Estado do FFmpeg
      let ffmpeg = null;
      let loaded = false;

      // Escuta mensagens do parent (offscreen.js)
      window.addEventListener("message", async (event) => {
        const { type, id, data } = event.data;

        try {
          let result;

          switch (type) {
            case "INIT":
              result = await initFFmpeg();
              break;

            case "CONVERT":
              result = await convertToMP4(data.webmData, data.fps);
              break;

            case "TERMINATE":
              result = terminateFFmpeg();
              break;

            default:
              throw new Error(`Tipo desconhecido: ${type}`);
          }

          // Envia resposta de sucesso
          parent.postMessage({ id, success: true, result }, "*");
        } catch (error) {
          console.error("[Sandbox] Erro:", error);
          // Envia resposta de erro
          parent.postMessage(
            {
              id,
              success: false,
              error: error.message || String(error),
            },
            "*"
          );
        }
      });

      // Inicializa FFmpeg
      async function initFFmpeg() {
        if (loaded && ffmpeg) {
          console.log("[Sandbox] FFmpeg já carregado");
          return { loaded: true };
        }

        console.log("[Sandbox] Inicializando FFmpeg...");

        // Verifica se FFmpegWASM está disponível
        if (typeof FFmpegWASM === "undefined") {
          throw new Error("FFmpegWASM não está carregado");
        }

        const { FFmpeg } = FFmpegWASM;
        ffmpeg = new FFmpeg();

        // Log de progresso
        ffmpeg.on("log", ({ message }) => {
          console.log("[FFmpeg]", message);
        });

        // Progresso
        ffmpeg.on("progress", ({ progress }) => {
          const percent = Math.round((progress || 0) * 100);
          console.log("[FFmpeg] Progresso:", percent + "%");
          parent.postMessage(
            {
              type: "PROGRESS",
              progress: percent,
            },
            "*"
          );
        });

        console.log("[Sandbox] Carregando core local...");

        // Carrega o core do FFmpeg a partir dos arquivos locais
        // Usa chrome.runtime.getURL para obter o caminho correto
        const baseURL = "../ffmpeg-core";

        try {
          await ffmpeg.load({
            coreURL: `${baseURL}/ffmpeg-core.js`,
            wasmURL: `${baseURL}/ffmpeg-core.wasm`,
          });
        } catch (loadError) {
          console.error("[Sandbox] Erro ao carregar core:", loadError);
          throw new Error(
            "Falha ao carregar FFmpeg core: " + loadError.message
          );
        }

        loaded = true;
        console.log("[Sandbox] FFmpeg carregado com sucesso!");
        return { loaded: true };
      }

      // Converte WebM para MP4
      async function convertToMP4(webmData, fps) {
        if (!loaded || !ffmpeg) {
          console.log("[Sandbox] FFmpeg não carregado, inicializando...");
          await initFFmpeg();
        }

        console.log("[Sandbox] Iniciando conversão...");
        console.log(`[Sandbox] Dados: ${webmData.length} bytes, FPS: ${fps}`);

        // Escreve arquivo de entrada
        const inputData = new Uint8Array(webmData);
        await ffmpeg.writeFile("input.webm", inputData);
        console.log("[Sandbox] Arquivo de entrada escrito");

        // Executa conversão
        console.log("[Sandbox] Executando ffmpeg...");
        await ffmpeg.exec([
          "-i",
          "input.webm",
          "-r",
          String(fps),
          "-c:v",
          "libx264",
          "-preset",
          "medium",
          "-crf",
          "18",
          "-profile:v",
          "high",
          "-level",
          "4.2",
          "-c:a",
          "aac",
          "-b:a",
          "192k",
          "-ar",
          "48000",
          "-movflags",
          "+faststart",
          "-pix_fmt",
          "yuv420p",
          "-vsync",
          "cfr",
          "output.mp4",
        ]);

        console.log("[Sandbox] Lendo arquivo de saída...");

        // Lê arquivo de saída
        const mp4Data = await ffmpeg.readFile("output.mp4");
        console.log(`[Sandbox] MP4 gerado: ${mp4Data.length} bytes`);

        // Limpa arquivos
        try {
          await ffmpeg.deleteFile("input.webm");
          await ffmpeg.deleteFile("output.mp4");
        } catch (e) {
          console.warn("[Sandbox] Erro ao limpar arquivos:", e);
        }

        console.log("[Sandbox] Conversão concluída!");

        // Retorna como array (será reconstruído como Blob no parent)
        return { mp4Data: Array.from(mp4Data) };
      }

      // Termina FFmpeg
      function terminateFFmpeg() {
        if (ffmpeg) {
          try {
            ffmpeg.terminate();
          } catch (e) {}
          ffmpeg = null;
          loaded = false;
        }
        return { terminated: true };
      }

      // Notifica que o sandbox está pronto
      console.log("[Sandbox] Inicializado!");
      parent.postMessage({ type: "READY" }, "*");
    </script>
  </body>
</html>
